// Code generated by MockGen. DO NOT EDIT.
// Source: ../control/gen-external-interface.go

// Package mock is a generated GoMock package.
package mock

import (
	opintent "github.com/HyperService-Consortium/go-uip/op-intent"
	parser "github.com/HyperService-Consortium/go-uip/op-intent/parser"
	uip "github.com/HyperService-Consortium/go-uip/uip"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// OpIntentInitializer is a mock of InitializerI interface
type OpIntentInitializer struct {
	ctrl     *gomock.Controller
	recorder *OpIntentInitializerMockRecorder
}

// OpIntentInitializerMockRecorder is the mock recorder for OpIntentInitializer
type OpIntentInitializerMockRecorder struct {
	mock *OpIntentInitializer
}

// NewOpIntentInitializer creates a new mock instance
func NewOpIntentInitializer(ctrl *gomock.Controller) *OpIntentInitializer {
	mock := &OpIntentInitializer{ctrl: ctrl}
	mock.recorder = &OpIntentInitializerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *OpIntentInitializer) EXPECT() *OpIntentInitializerMockRecorder {
	return m.recorder
}

// Parse mocks base method
func (m *OpIntentInitializer) Parse(arg0 opintent.OpIntents) (parser.TxIntents, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Parse", arg0)
	ret0, _ := ret[0].(parser.TxIntents)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Parse indicates an expected call of Parse
func (mr *OpIntentInitializerMockRecorder) Parse(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Parse", reflect.TypeOf((*OpIntentInitializer)(nil).Parse), arg0)
}

// ParseR mocks base method
func (m *OpIntentInitializer) ParseR(arg0 opintent.OpIntentsPacket) (parser.TxIntents, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ParseR", arg0)
	ret0, _ := ret[0].(parser.TxIntents)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ParseR indicates an expected call of ParseR
func (mr *OpIntentInitializerMockRecorder) ParseR(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ParseR", reflect.TypeOf((*OpIntentInitializer)(nil).ParseR), arg0)
}

// Parse_ mocks base method
func (m *OpIntentInitializer) Parse_(arg0 *parser.LexerResult) (parser.TxIntents, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Parse_", arg0)
	ret0, _ := ret[0].(parser.TxIntents)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Parse_ indicates an expected call of Parse_
func (mr *OpIntentInitializerMockRecorder) Parse_(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Parse_", reflect.TypeOf((*OpIntentInitializer)(nil).Parse_), arg0)
}

// TopologicalSort mocks base method
func (m *OpIntentInitializer) TopologicalSort(arg0 opintent.ArrayI, arg1 []parser.Dependency) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TopologicalSort", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// TopologicalSort indicates an expected call of TopologicalSort
func (mr *OpIntentInitializerMockRecorder) TopologicalSort(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TopologicalSort", reflect.TypeOf((*OpIntentInitializer)(nil).TopologicalSort), arg0, arg1)
}

// BlockChainInterface is a mock of BlockChainInterfaceI interface
type BlockChainInterface struct {
	ctrl     *gomock.Controller
	recorder *BlockChainInterfaceMockRecorder
}

// BlockChainInterfaceMockRecorder is the mock recorder for BlockChainInterface
type BlockChainInterfaceMockRecorder struct {
	mock *BlockChainInterface
}

// NewBlockChainInterface creates a new mock instance
func NewBlockChainInterface(ctrl *gomock.Controller) *BlockChainInterface {
	mock := &BlockChainInterface{ctrl: ctrl}
	mock.recorder = &BlockChainInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *BlockChainInterface) EXPECT() *BlockChainInterfaceMockRecorder {
	return m.recorder
}

// CheckAddress mocks base method
func (m *BlockChainInterface) CheckAddress(arg0 []uint8) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckAddress", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// CheckAddress indicates an expected call of CheckAddress
func (mr *BlockChainInterfaceMockRecorder) CheckAddress(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckAddress", reflect.TypeOf((*BlockChainInterface)(nil).CheckAddress), arg0)
}

// Deserialize mocks base method
func (m *BlockChainInterface) Deserialize(arg0 []uint8) (uip.RawTransaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Deserialize", arg0)
	ret0, _ := ret[0].(uip.RawTransaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Deserialize indicates an expected call of Deserialize
func (mr *BlockChainInterfaceMockRecorder) Deserialize(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Deserialize", reflect.TypeOf((*BlockChainInterface)(nil).Deserialize), arg0)
}

// GetStorageAt mocks base method
func (m *BlockChainInterface) GetStorageAt(arg0 uint64, arg1 uint16, arg2, arg3, arg4 []uint8) (uip.Variable, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStorageAt", arg0, arg1, arg2, arg3, arg4)
	ret0, _ := ret[0].(uip.Variable)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetStorageAt indicates an expected call of GetStorageAt
func (mr *BlockChainInterfaceMockRecorder) GetStorageAt(arg0, arg1, arg2, arg3, arg4 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStorageAt", reflect.TypeOf((*BlockChainInterface)(nil).GetStorageAt), arg0, arg1, arg2, arg3, arg4)
}

// GetTransactionProof mocks base method
func (m *BlockChainInterface) GetTransactionProof(arg0 uint64, arg1, arg2 []uint8) (uip.MerkleProof, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTransactionProof", arg0, arg1, arg2)
	ret0, _ := ret[0].(uip.MerkleProof)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTransactionProof indicates an expected call of GetTransactionProof
func (mr *BlockChainInterfaceMockRecorder) GetTransactionProof(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTransactionProof", reflect.TypeOf((*BlockChainInterface)(nil).GetTransactionProof), arg0, arg1, arg2)
}

// MustWithSigner mocks base method
func (m *BlockChainInterface) MustWithSigner() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MustWithSigner")
	ret0, _ := ret[0].(bool)
	return ret0
}

// MustWithSigner indicates an expected call of MustWithSigner
func (mr *BlockChainInterfaceMockRecorder) MustWithSigner() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MustWithSigner", reflect.TypeOf((*BlockChainInterface)(nil).MustWithSigner))
}

// ParseTransactionIntent mocks base method
func (m *BlockChainInterface) ParseTransactionIntent(arg0 uip.TxIntentI) (uip.TxIntentI, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ParseTransactionIntent", arg0)
	ret0, _ := ret[0].(uip.TxIntentI)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ParseTransactionIntent indicates an expected call of ParseTransactionIntent
func (mr *BlockChainInterfaceMockRecorder) ParseTransactionIntent(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ParseTransactionIntent", reflect.TypeOf((*BlockChainInterface)(nil).ParseTransactionIntent), arg0)
}

// RouteRaw mocks base method
func (m *BlockChainInterface) RouteRaw(arg0 uint64, arg1 uip.RawTransaction) ([]uint8, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RouteRaw", arg0, arg1)
	ret0, _ := ret[0].([]uint8)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RouteRaw indicates an expected call of RouteRaw
func (mr *BlockChainInterfaceMockRecorder) RouteRaw(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RouteRaw", reflect.TypeOf((*BlockChainInterface)(nil).RouteRaw), arg0, arg1)
}

// RouteWithSigner mocks base method
func (m *BlockChainInterface) RouteWithSigner(arg0 uip.Signer) (uip.Router, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RouteWithSigner", arg0)
	ret0, _ := ret[0].(uip.Router)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RouteWithSigner indicates an expected call of RouteWithSigner
func (mr *BlockChainInterfaceMockRecorder) RouteWithSigner(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RouteWithSigner", reflect.TypeOf((*BlockChainInterface)(nil).RouteWithSigner), arg0)
}

// Translate mocks base method
func (m *BlockChainInterface) Translate(arg0 uip.TransactionIntent, arg1 uip.Storage) (uip.RawTransaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Translate", arg0, arg1)
	ret0, _ := ret[0].(uip.RawTransaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Translate indicates an expected call of Translate
func (mr *BlockChainInterfaceMockRecorder) Translate(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Translate", reflect.TypeOf((*BlockChainInterface)(nil).Translate), arg0, arg1)
}

// WaitForTransact mocks base method
func (m *BlockChainInterface) WaitForTransact(arg0 uint64, arg1 []uint8, arg2 ...interface{}) ([]uint8, []uint8, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WaitForTransact", varargs...)
	ret0, _ := ret[0].([]uint8)
	ret1, _ := ret[1].([]uint8)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// WaitForTransact indicates an expected call of WaitForTransact
func (mr *BlockChainInterfaceMockRecorder) WaitForTransact(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WaitForTransact", reflect.TypeOf((*BlockChainInterface)(nil).WaitForTransact), varargs...)
}
